{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Commercial Auto Reserving\"\noutput: \n  html_document:\n   toc: true\n   toc_depth: 2\n   toc_float: true\n   code_folding: hide\n   self_contained: false\n---\n\n> Data prepared by Glenn G. Meyer and Peng Shi and obtained from [CAS website](http://www.casact.org/research/index.cfm?fa=loss_reserves_data). \n\n\n```{r, echo=FALSE, warning=FALSE, message=FALSE}\n\nrequire(\"dplyr\")\nrequire(\"tidyr\")\nrequire(\"DT\")\nrequire(\"ggplot2\")\nrequire(\"scales\")\nrequire(\"plotly\")\nrequire(\"RColorBrewer\")\n\n\n################################\n#### Commercial auto\ncomm.auto <- read.table(\"C:/Data/Actuariat/Reserving/data/comauto_pos.csv\", sep=\",\", header = T, stringsAsFactors = F)\ncomm.auto<- rename_(comm.auto, .dots = c(\"incurred\"=\"IncurLoss_C\",\n                                         \"cum.paid\"=\"CumPaidLoss_C\",\n                                         \"earned.prm.dir\"=\"EarnedPremDIR_C\",\n                                         \"earned.prm.net\"=\"EarnedPremNet_C\",\n                                         \"claim.year\"=\"AccidentYear\",\n                                         \"dev.year\"=\"DevelopmentYear\"))\n\ncomm.auto<-mutate(comm.auto, lag=dev.year-claim.year, CY=claim.year+lag)\n\n\n#################################\n### Data Preperation function\nDataPrep<-function(data, split=\"claim.year\", lag=\"lag\", id=\"CY\") {\n  \n  data<-data %>% group_by_(.dots=c(split, lag, id)) %>% \n    summarise_each_(funs(sum(.,na.rm=T)), vars=c(\"incurred\",\"cum.paid\",\"earned.prm.dir\",\"earned.prm.net\")) %>% \n    ungroup()\n  data.previous<-data %>% select_(.dots=c(split,lag, \"incurred\",\"cum.paid\")) %>% \n    mutate(lag=lag+1) %>% \n    rename_(.dots=c(\"incurred_prev\"=\"incurred\",\"cum.paid_prev\"=\"cum.paid\"))\n  data<-left_join(data, data.previous, by=c(split,lag))\n  data<-data %>% mutate(LR.paid=cum.paid/earned.prm.dir,\n                        LR.paid_prev=cum.paid_prev/earned.prm.dir,\n                        paid=ifelse(is.na(cum.paid_prev), \n                                    cum.paid, \n                                    cum.paid-cum.paid_prev))\n  \n  return(data)\n}\n\n#################################\n### Triangle functions\nTriPrep<-function(data, split=\"claim.year\", lag=\"lag\", var, type=\"currency\") {\n  \n  data<-data %>% group_by_(.dots=c(split, lag)) %>% \n    summarise_each_(funs(sum(.,na.rm=T)), vars=var) %>% \n    ungroup()\n  \n  if (type==\"currency\") {\n    data <- data %>% mutate_each_(funs(round(., digits=0)), vars=var)\n    #data[[var]] <- round(data[[var]],digits=0)\n  }\n  \n  data <- data %>% select_(.dots=c(split, lag, var)) %>% spread_(key_col=lag, value_col=var)\n  \n  data.DT <- datatable(data,filter = \"none\", rownames = F, selection = \"none\", class=\"compact hover\",\n                       options =  list(\n                         searching=F,\n                         paging=F,\n                         info=F,\n                         ordering=F,\n                         scrollX=T,\n                         columnDefs = list(list(className = 'dt-center', targets=1:ncol(data)-1)))\n  )\n  \n  if (type==\"currency\") {\n    data.DT<- data.DT %>% formatCurrency(columns=2:ncol(data), currency = \"\", mark = \",\", digits = 0)\n  } else {\n    data.DT<- data.DT %>% formatPercentage(columns=2:ncol(data), digits = 1)\n  }\n  \n  return(data.DT)\n}\n\n\n###############################################\n#### Prediction function on cumulative model\n\nPredReserveCum <- function(model, data, CY.ini, lag.max=9, label) {\n  pred<-NULL\n  data<-data %>% filter(CY==CY.ini)\n  \n  for (i in 1:lag.max) {\n    data <- data %>% mutate(lag=lag+1, \n                            CY=CY+1, \n                            cum.paid_prev=cum.paid,\n                            incurred_prev=incurred, \n                            LR.paid_prev=cum.paid_prev/earned.prm.dir) %>%\n      filter(lag<=lag.max)\n    \n    if (label==\"lnorm\") {\n      data$cum.paid <- exp(predict(object=model, newdata=data, type=\"response\"))\n    } else {\n      data$cum.paid <- predict(object=model, newdata=data, type=\"response\")\n    }\n    \n    data <- data %>% mutate(LR.paid=cum.paid/earned.prm.dir)\n    \n    pred <- bind_rows(pred, data)\n  }\n  \n  pred$model<-paste(label,\"cum\",sep=\"_\")\n  pred\n}\n\n\n##############################################\n#### Prediction function on incremental model\n\nPredReserveInc <- function(model, data, CY.ini, lag.max=9, label) {\n  pred<-NULL\n  data<-data %>% filter(CY==CY.ini)\n  \n  for (i in 1:lag.max) {\n    data <- data %>% mutate(lag=lag+1, \n                            CY=CY+1, \n                            cum.paid_prev=cum.paid,\n                            incurred_prev=incurred, \n                            LR.paid_prev=cum.paid_prev/earned.prm.dir) %>%\n      filter(lag<=lag.max)\n    \n    if (label==\"lnorm\") {\n      data$paid <- exp(predict(object=model, newdata=data, type=\"response\"))\n    } else {\n      data$paid <- predict(object=model, newdata=data, type=\"response\")\n    }\n    \n    data <- data %>% mutate(cum.paid= ifelse(is.na(cum.paid_prev), \n                                             paid, \n                                             cum.paid_prev+paid),\n                            LR.paid=cum.paid/earned.prm.dir)\n    \n    pred <- bind_rows(pred, data)\n  }\n  \n  pred$model<-paste(label,\"inc\",sep=\"_\")\n  pred\n}\n\n\n\n```\n\n#Data overview\n\n\\ \n\n##Cumulative paid amount\n\n```{r, echo=FALSE}\n\n#Prepare initial data\ndata.prep<-DataPrep(comm.auto, split = \"claim.year\", lag=\"lag\", id = \"CY\")\n#data.prep<-DataPrep(pp.auto,split = \"claim.year\", lag=\"lag\")\n#data.prep<-DataPrep(prod.liab,split = \"claim.year\", lag=\"lag\")\n\n(tri.paid<- TriPrep(data.prep, split = \"claim.year\",lag = \"lag\", var=\"cum.paid\", type = \"currency\"))\n\n\n```\n\n\n\\ \n\n##Cumulative paid Loss ratio\n\n```{r, echo=FALSE}\n\n(tri.LR.paid<- TriPrep(data.prep, split = \"claim.year\",lag = \"lag\", var=\"LR.paid\", type=\"percent\"))\n\n```\n\n***\n\n\\ \n\n##Chain-Ladder with GLM\n\nThis basic reserving approach express the expected cumulative metric (typically either incurred or paid) seen at next development period as a directly proportional to previous development measure. \n\n$$ Cumulative_{t} = LDF_{t-1} * Cumulative_{t-1} $$\n\nWhere $LDF_{t-1}$ is the loss development factor for period $t-1$ to $t$ derived from past experience. \n\nSuch representation can be modeled in various ways using a GLM approach.\n\n- Using a identity relationship : \n    - Model $Cumulative_t$ using interaction of the development period and $Cumulative_{t-1}$ as the single predictor and include no intercept term. A Normal error distribution will be used. \n\n- Using a log relationship: \n    - Model $Cumulative_t$ using the development period as predictor variable and use $log(Cumulative_{t-1})$ as an offset term. Inclusion of an intercept term is optional and won't affect the outcome. Various error distributions can be used : Poisson, quasi/over-dispersed Poisson, Gamma, Log-Normal, Pareto, etc. \n\n\\ \n\nAn alternative perspective is to model the incremental amount between $t-1$ and $t$. \n\n$$ \\begin{align*}\nCumulative_{t}- Cumulative_{t-1} &= LDF_{t-1} * Cumulative_{t-1} - Cumulative_{t-1} \\\\\nIncremental_{t} &= (LDF_{t-1}-1) * Cumulative_{t-1} \\\\\n&= IDF_{t-1} * Cumulative_{t-1} \\\\\n\\end{align*}$$\n\nSuch representation can also be modeled in various ways using a GLM approach.\n\n- Using a identity relationship : \n    - Model $Incremental_t$ using interaction of the development period and $Incurred_{t-1}$ as the single predictor and include no intercept term. A Normal error distribution will be used. \n\n- Using a log relationship: \n    - Model $Incremental_t$ using the development period as predictor variable and use $log(Incurred_{t-1})$ as an offset term. Inclusion of an intercept term is optional and won't affect the outcome. Various error distributions can be used : Poisson, quasi/over-dispersed Poisson, Gamma, Log-Normal, Pareto, etc. \n\n***\n\n\n\\ \n\n#Model design\n\n```{r, echo=TRUE, warning=FALSE, message=F}\n\n### prepare modelisation data\n#Keep all data points up to CY 1997 except the development 0 point\ndata.fit<-filter(data.prep, !is.na(incurred_prev), CY<=1997)\n\n\n#### Cumulative models\nfit.glm.norm.cum<-glm(cum.paid~factor(lag):cum.paid_prev-1, data=data.fit, family=gaussian(link = \"identity\"))\ncoef(fit.glm.norm.cum)\n\nfit.glm.pois.cum<-glm(cum.paid~factor(lag), data=data.fit, family=poisson(link = \"log\"), offset=log(cum.paid_prev))\nexp(coef(fit.glm.pois.cum))\n\nfit.glm.quasi.pois.cum<-glm(cum.paid~factor(lag)-1, data=data.fit, family=quasipoisson(link = \"log\"), offset=log(cum.paid_prev))\n\nfit.glm.gamma.cum<-glm(cum.paid~factor(lag), data=data.fit, family=Gamma(link = \"log\"), offset=log(cum.paid_prev))\n\nfit.glm.lnorm.cum<-glm(log(cum.paid)~factor(lag), data=data.fit, family=gaussian(link = \"identity\"), offset=log(cum.paid_prev))\n\n\n#### Incremental models\nfit.glm.norm.inc<-glm(paid~factor(lag):cum.paid_prev-1, data=data.fit, family=gaussian(link = \"identity\"))\ncoef(fit.glm.norm.inc)\n\nfit.glm.norm.inc.interc<-glm(paid~factor(lag):cum.paid_prev, data=data.fit, family=gaussian(link = \"identity\"))\ncoef(fit.glm.norm.inc)\n\nfit.glm.pois.inc<-glm(paid~factor(lag), data=data.fit, family=poisson(link = \"log\"), offset=log(cum.paid_prev))\nsummary(fit.glm.pois.inc)\n\nfit.glm.quasi.pois.inc<-glm(paid~factor(lag)-1, data=data.fit, family=quasipoisson(link = \"log\"), offset=log(cum.paid_prev))\nsummary(fit.glm.quasi.pois.inc)\n\nfit.glm.gamma.inc<-glm(paid~factor(lag), data=data.fit, family=Gamma(link = \"log\"), offset=log(cum.paid_prev))\n\nfit.glm.lnorm.inc<-glm(log(paid)~factor(lag), data=data.fit, family=gaussian(link = \"identity\"), offset=log(cum.paid_prev))\n\n\n``` \n\n\n\\ \n\n##Comparison of model predictions with actual results\n\n```{r, echo=F, warning=FALSE, message=FALSE}\n\n### Prepare prediction data\n### Data as of CY 1997\ndata.pred<-filter(data.prep, CY<=1997)\n\n\n#### Cumulative models\npred.norm.cum<-PredReserveCum(model=fit.glm.norm.cum, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"norm\")\npred.pois.cum<-PredReserveCum(model=fit.glm.pois.cum, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"pois\")\npred.quasi.pois.cum<-PredReserveCum(model=fit.glm.quasi.pois.cum, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"quasi.pois\")\npred.gamma.cum<-PredReserveCum(model=fit.glm.gamma.cum, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"gamma\")\npred.lnorm.cum<-PredReserveCum(model=fit.glm.lnorm.cum, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"lnorm\")\n\n\n#### Incremental models\npred.norm.inc<-PredReserveInc(model=fit.glm.norm.inc, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"norm\")\npred.norm.inc.interc<-PredReserveInc(model=fit.glm.norm.inc.interc, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"norm_interc\")\npred.pois.inc<-PredReserveInc(model=fit.glm.pois.inc, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"pois\")\npred.quasi.pois.inc<-PredReserveInc(model=fit.glm.quasi.pois.inc, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"quasi.pois\")\npred.gamma.inc<-PredReserveInc(model=fit.glm.gamma.inc, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"gamma\")\npred.lnorm.inc<-PredReserveInc(model=fit.glm.lnorm.inc, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"lnorm\")\n\n\nactual.pred<-data.prep %>% arrange(claim.year, lag) %>% group_by_(.dots=c(\"claim.year\")) %>% \n  summarise(cum.paid=last(cum.paid), LR.paid=last(LR.paid)) %>% mutate(model=\"actual\")\n\nmodel.pred<- bind_rows(pred.norm.inc, pred.norm.inc.interc, pred.quasi.pois.inc, pred.quasi.pois.cum, pred.gamma.inc, pred.gamma.cum, pred.lnorm.inc, actual.pred)\n\nmodel.pred<-model.pred %>% arrange(model, claim.year, lag) %>% group_by_(.dots=c(\"model\",\"claim.year\")) %>% \n  summarise(cum.paid=last(cum.paid), LR.paid=last(LR.paid))\n\n### Plot model performance comparison\nplot_ly(data=model.pred, x=~claim.year, y=~LR.paid, color=~model, colors = c(\"gold\",\"darkgreen\",\"blue\"), type=\"scatter\", mode=\"lines+markers\") %>% \n  config(editable=F, showLink=F, sendData=F)\n\n``` \n\n\n\\ \n\nIt can be observed that the incremental and cumulative models result in the same predicted outcomes. Given that the incremental model allow for more flexible model design,it is that structure that will be employed ongoing. \n\n- Having an intercept term for the log model result in the same outcome. \n\n- Adding an intercept term on an additional model structure has an influence on the outcome. \n\n- Poisson and quasi-Poisson result in the same prediction. However, the underlying modeled variance is different and thus the quasi-Poisson will be preferred since the dispersion if significantly greater than the fixed mean/variation relationship implied by the simple Poisson distribution. \n\n\nPoisson projected LR\n\n```{r, echo=FALSE}\n\nTriPrep(pred.pois.inc, split = \"claim.year\",lag = \"lag\", var=\"LR.paid\", type=\"percent\")\n\n``` \n\n\\ \n\nLog-normal projected LR\n\n```{r, echo=FALSE}\n\nTriPrep(pred.lnorm.inc, split = \"claim.year\",lag = \"lag\", var=\"LR.paid\", type=\"percent\")\n\n``` \n\n\\ \n\n\n#Incremental paid with trending on accident year\n\n\n```{r, echo=TRUE, warning=FALSE, message=F}\n\n### prepare modelisation data\n#Keep all data points up to CY 1997 except the development 0 point\ndata.fit<-filter(data.prep, !is.na(incurred_prev), CY<=1997)\n\n\nfit.glm.quasi.pois<-glm(paid~factor(lag):log(cum.paid_prev) + claim.year, data=data.fit, family=quasipoisson(link = \"log\"))\n\nfit.glm.lnorm<-glm(log(paid)~factor(lag):log(cum.paid_prev) + claim.year, data=data.fit, family=gaussian(link = \"identity\"))\n\nfit.glm.norm<-glm(paid~factor(lag):cum.paid_prev + claim.year, data=data.fit, family=gaussian(link = \"identity\"))\n\n``` \n\n\\ \n\n##Comparison of model predictions with actual results\n\n```{r, echo=F, warning=FALSE, message=FALSE}\n\n### Prepare prediction data\n### Data as of CY 1997\ndata.pred<-filter(data.prep, CY<=1997)\n\npred.quasi.pois<-PredReserveInc(model=fit.glm.quasi.pois, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"quasi.pois\")\npred.lnorm<-PredReserveInc(model=fit.glm.lnorm, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"lnorm\")\npred.norm<-PredReserveInc(model=fit.glm.norm, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"norm\")\n\n\nactual.pred<-data.prep %>% arrange(claim.year, lag) %>% group_by_(.dots=c(\"claim.year\")) %>% \n  summarise(cum.paid=last(cum.paid), LR.paid=last(LR.paid)) %>% mutate(model=\"actual\")\n\nmodel.pred<- bind_rows(pred.quasi.pois, pred.lnorm, pred.norm, actual.pred)\n\nmodel.pred<-model.pred %>% arrange(model, claim.year, lag) %>% group_by_(.dots=c(\"model\",\"claim.year\")) %>% \n  summarise(cum.paid=last(cum.paid), LR.paid=last(LR.paid))\n\n### Plot model performance comparison\nplot_ly(data=model.pred, x=~claim.year, y=~LR.paid, color=~model, colors = c(\"gold\",\"darkgreen\",\"blue\"), type=\"scatter\", mode=\"lines+markers\") %>% \n  config(editable=F, showLink=F, sendData=F)\n\n\n``` \n\n\\ \n\n#Incremental paid with trending on calendar year\n\n```{r, echo=TRUE, warning=FALSE, message=F}\n\n### prepare modelisation data\n#Keep all data points up to CY 1997 except the development 0 point\ndata.fit<-filter(data.prep, !is.na(incurred_prev), CY<=1997)\n\nfit.glm.quasi.pois<-glm(paid~factor(lag):log(cum.paid_prev) + CY, data=data.fit, family=quasipoisson(link = \"log\"))\n\nfit.glm.lnorm<-glm(log(paid)~factor(lag):log(cum.paid_prev) + CY, data=data.fit, family=gaussian(link = \"identity\"))\n\nfit.glm.norm<-glm(paid~factor(lag):cum.paid_prev + CY, data=data.fit, family=gaussian(link = \"identity\"))\n\n\n``` \n\n\\ \n\n##Comparison of model predictions with actual results\n\n```{r, echo=F, warning=FALSE, message=FALSE}\n\n### Prepare prediction data\n### Data as of CY 1997\ndata.pred<-filter(data.prep, CY<=1997)\n\n\npred.quasi.pois<-PredReserveInc(model=fit.glm.quasi.pois, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"quasi.pois\")\npred.lnorm<-PredReserveInc(model=fit.glm.lnorm, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"lnorm\")\npred.norm<-PredReserveInc(model=fit.glm.norm, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"norm\")\n\n\nactual.pred<-data.prep %>% arrange(claim.year, lag) %>% group_by_(.dots=c(\"claim.year\")) %>% \n  summarise(cum.paid=last(cum.paid), LR.paid=last(LR.paid)) %>% mutate(model=\"actual\")\n\nmodel.pred<- bind_rows(pred.quasi.pois, pred.lnorm, pred.norm, actual.pred)\n\nmodel.pred<-model.pred %>% arrange(model, claim.year, lag) %>% group_by_(.dots=c(\"model\",\"claim.year\")) %>% \n  summarise(cum.paid=last(cum.paid), LR.paid=last(LR.paid))\n\n### Plot model performance comparison\nplot_ly(data=model.pred, x=~claim.year, y=~LR.paid, color=~model, colors = c(\"gold\",\"darkgreen\",\"blue\"), type=\"scatter\", mode=\"lines+markers\") %>% \n  config(editable=F, showLink=F, sendData=F)\n\n\n``` \n\n\\ \n\n\n#Incremental paid based on earned premium\n\nSuch approach is similar in perspective to Bornhuetter-Ferguson to the extent that the future incremental payments are independent of past payments and assumed to be a fixed percentage of the earned premium. Main difference with B-F is that there's no assumed *a priori* loss ratio, the % of earned premium paid at each lag is derived entirely from the data rather than from external hypothesis. \n\n\n```{r, echo=TRUE, warning=FALSE, message=F}\n\n### prepare modelisation data\n#Keep all data points up to CY 1997 except the development 0 point\ndata.fit<-filter(data.prep, !is.na(incurred_prev), CY<=1997)\n\nfit.glm.quasi.pois<-glm(paid~factor(lag):log(earned.prm.dir), data=data.fit, family=quasipoisson(link = \"log\"))\n\nfit.glm.gamma<-glm(paid~factor(lag):log(earned.prm.dir), data=data.fit, family=Gamma(link = \"log\"))\n\nfit.glm.lnorm<-glm(log(paid)~factor(lag):log(earned.prm.dir), data=data.fit, family=gaussian(link = \"identity\"))\n\nfit.glm.norm<-glm(paid~factor(lag):earned.prm.dir-1, data=data.fit, family=gaussian(link = \"identity\"))\n\n\n``` \n\n\\ \n\n##Comparison of model predictions with actual results\n\n```{r, echo=F, warning=FALSE, message=FALSE}\n\n### Prepare prediction data\n### Data as of CY 1997\ndata.pred<-filter(data.prep, CY<=1997)\n\n\npred.quasi.pois<-PredReserveInc(model=fit.glm.quasi.pois, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"quasi.pois\")\npred.gamma<-PredReserveInc(model=fit.glm.gamma, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"gamma\")\npred.lnorm<-PredReserveInc(model=fit.glm.lnorm, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"lnorm\")\npred.norm<-PredReserveInc(model=fit.glm.norm, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"norm\")\n\n\nactual.pred<-data.prep %>% arrange(claim.year, lag) %>% group_by_(.dots=c(\"claim.year\")) %>% \n  summarise(cum.paid=last(cum.paid), LR.paid=last(LR.paid)) %>% mutate(model=\"actual\")\n\nmodel.pred<- bind_rows(pred.quasi.pois, pred.gamma, pred.lnorm, pred.norm, actual.pred)\n\nmodel.pred<-model.pred %>% arrange(model, claim.year, lag) %>% group_by_(.dots=c(\"model\",\"claim.year\")) %>% \n  summarise(cum.paid=last(cum.paid), LR.paid=last(LR.paid))\n\n### Plot model performance comparison\nplot_ly(data=model.pred, x=~claim.year, y=~LR.paid, color=~model, colors = c(\"gold\",\"darkgreen\",\"blue\"), type=\"scatter\", mode=\"lines+markers\") %>% \n  config(editable=F, showLink=F, sendData=F)\n\n``` \n\n\\ \n\n\n#Incremental payment based on cumulative paid and earned premium\n\nAdding flexibility by mixing dependency on both cumulative paid and earned premium.\n\n```{r, echo=TRUE, warning=FALSE, message=F}\n\n### prepare modelisation data\n#Keep all data points up to CY 1997 except the development 0 point\ndata.fit<-filter(data.prep, !is.na(incurred_prev), CY<=1997)\n\nfit.glm.quasi.pois<-glm(paid~ factor(lag):log(cum.paid_prev) + factor(lag):log(earned.prm.dir), data=data.fit, family=quasipoisson(link = \"log\"))\n\nfit.glm.gamma<-glm(paid ~ factor(lag):log(cum.paid_prev) + factor(lag):log(earned.prm.dir), data=data.fit, family=Gamma(link = \"log\"))\n\nfit.glm.lnorm<-glm(log(paid)~ factor(lag):log(cum.paid_prev) + factor(lag):log(earned.prm.dir), data=data.fit, family=gaussian(link = \"identity\"))\n\nfit.glm.norm<-glm(paid~ factor(lag):cum.paid_prev + factor(lag):earned.prm.dir - 1, data=data.fit, family=gaussian(link = \"identity\"))\n\n\n``` \n\n\n\\ \n\n##Comparison of model predictions with actual results\n\n```{r, echo=F, warning=FALSE, message=FALSE}\n\n### Prepare prediction data\n### Data as of CY 1997\ndata.pred<-filter(data.prep, CY<=1997)\n\n\npred.quasi.pois<-PredReserveInc(model=fit.glm.quasi.pois, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"quasi.pois\")\npred.gamma<-PredReserveInc(model=fit.glm.gamma, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"gamma\")\npred.lnorm<-PredReserveInc(model=fit.glm.lnorm, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"lnorm\")\npred.norm<-PredReserveInc(model=fit.glm.norm, data=data.pred, lag.max = 9, CY.ini = 1997, label=\"norm\")\n\n\nactual.pred<-data.prep %>% arrange(claim.year, lag) %>% group_by_(.dots=c(\"claim.year\")) %>% \n  summarise(cum.paid=last(cum.paid), LR.paid=last(LR.paid)) %>% mutate(model=\"actual\")\n\nmodel.pred<- bind_rows(pred.quasi.pois, pred.gamma, pred.lnorm, pred.norm, actual.pred)\n\nmodel.pred<-model.pred %>% arrange(model, claim.year, lag) %>% group_by_(.dots=c(\"model\",\"claim.year\")) %>% \n  summarise(cum.paid=last(cum.paid), LR.paid=last(LR.paid))\n\n### Plot model performance comparison\nplot_ly(data=model.pred, x=~claim.year, y=~LR.paid, color=~model, colors = c(\"gold\",\"darkgreen\",\"blue\"), type=\"scatter\", mode=\"lines+markers\") %>% \n  config(editable=F, showLink=F, sendData=F)\n\n``` \n\n",
    "created" : 1509517856568.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3229958490",
    "id" : "F050EFCD",
    "lastKnownWriteTime" : 1480403382,
    "last_content_update" : 1480403382,
    "path" : "C:/Data/GitHub/jeremiedb.github.io/docs_make/reserving_comm_auto_new.Rmd",
    "project_path" : "reserving_comm_auto_new.Rmd",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}